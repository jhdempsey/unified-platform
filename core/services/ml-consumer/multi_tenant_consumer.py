"""Multi-Tenant ML Consumer - Tenant isolation and routing."""

import json
import sys
from collections import defaultdict
from datetime import datetime
from pathlib import Path
from typing import Any, Dict

from confluent_kafka import Consumer, KafkaError, Producer
from prometheus_client import Counter, Gauge, start_http_server

sys.path.insert(0, str(Path(__file__).parent.parent.parent))

from ml.models.demand_forecasting.model import DemandForecastingModel
from ml.models.inventory_optimization.model import InventoryOptimizationModel
from ml.models.supplier_reliability.model import SupplierReliabilityModel

# Multi-tenant metrics
EVENTS_BY_TENANT = Counter(
    "ml_events_by_tenant_total", "Events processed by tenant", ["tenant_id"]
)
ALERTS_BY_TENANT = Counter(
    "ml_alerts_by_tenant_total", "Alerts generated by tenant", ["tenant_id"]
)
ACTIVE_TENANTS = Gauge("ml_active_tenants", "Number of active tenants")


class MultiTenantConsumer:
    """ML Consumer with multi-tenant support and isolation."""

    def __init__(
        self, bootstrap_servers: str = "localhost:9092", metrics_port: int = 9091
    ):
        # Start metrics
        try:
            start_http_server(metrics_port)
            print(f"üìä Multi-tenant metrics on port {metrics_port}")
        except OSError:
            print(f"‚ö†Ô∏è  Metrics server already running on {metrics_port}")

        self.consumer_config = {
            "bootstrap.servers": bootstrap_servers,
            "group.id": "ml-consumer-multi-tenant",
            "auto.offset.reset": "earliest",
            "enable.auto.commit": False,
        }
        self.consumer = Consumer(self.consumer_config)

        self.producer_config = {
            "bootstrap.servers": bootstrap_servers,
            "client.id": "ml-producer-multi-tenant",
            "acks": "all",
            "enable.idempotence": True,
        }
        self.producer = Producer(self.producer_config)

        # Load models
        print("ü§ñ Loading ML models...")
        self.demand_model = DemandForecastingModel()
        self.supplier_model = SupplierReliabilityModel()
        self.inventory_model = InventoryOptimizationModel()
        print("‚úÖ Models loaded")

        # Tenant tracking
        self.tenant_stats = defaultdict(
            lambda: {"processed": 0, "alerts": 0, "revenue": 0.0}
        )
        self.active_tenants = set()

        # Tenant configurations (in production, load from database)
        self.tenant_configs = {
            "food-distributor-001": {
                "name": "FreshFood Distribution",
                "tier": "premium",
                "alert_threshold": 0.6,
            },
            "food-distributor-002": {
                "name": "QuickServe Logistics",
                "tier": "standard",
                "alert_threshold": 0.7,
            },
            "food-distributor-003": {
                "name": "GlobalFood Supply",
                "tier": "enterprise",
                "alert_threshold": 0.5,
            },
        }

    def get_tenant_topic(self, tenant_id: str, topic_type: str) -> str:
        """Get tenant-specific topic name for isolation."""
        # In production: tenant-specific topics for isolation
        # Format: supply-chain.{tenant_id}.{topic_type}
        return f"supply-chain.{topic_type}"  # Shared for demo

    def get_tenant_config(self, tenant_id: str) -> Dict[str, Any]:
        """Get tenant-specific configuration."""
        return self.tenant_configs.get(
            tenant_id,
            {"name": "Unknown Tenant", "tier": "standard", "alert_threshold": 0.65},
        )

    def predict_order_risk(self, order: Dict[str, Any]) -> Dict[str, Any]:
        """Predict with tenant-aware thresholds."""
        tenant_config = self.get_tenant_config(order["tenant_id"])

        risk_score = 0.0
        risk_score += (1 - order["supplier"]["reliability"]) * 0.4

        if order["product"]["perishable"]:
            shelf_life = order["product"]["shelf_life_days"]
            delivery_days = order["delivery_days"]
            if delivery_days > shelf_life * 0.5:
                risk_score += 0.3

        if order["distance_miles"] > 2000:
            risk_score += 0.2

        weather_weights = {"low": 0.0, "medium": 0.05, "high": 0.15}
        risk_score += weather_weights.get(order["weather_risk"], 0)

        risk_score = min(risk_score, 1.0)

        # Tenant-specific threshold
        threshold = tenant_config["alert_threshold"]
        if risk_score > threshold:
            risk_level = "high"
        elif risk_score > threshold * 0.6:
            risk_level = "medium"
        else:
            risk_level = "low"

        return {
            "model": "order_fulfillment_risk_v1",
            "risk_score": round(risk_score, 3),
            "on_time_probability": round(1 - risk_score, 3),
            "risk_level": risk_level,
            "tenant_threshold": threshold,
        }

    def process_order(self, order: Dict[str, Any]) -> Dict[str, Any]:
        """Process order with tenant context."""
        tenant_id = order["tenant_id"]

        # Track active tenants
        self.active_tenants.add(tenant_id)
        ACTIVE_TENANTS.set(len(self.active_tenants))

        # Risk prediction
        risk_prediction = self.predict_order_risk(order)

        # Supplier reliability
        supplier_features = {
            "supplier_id": order["supplier"]["id"],
            "historical_reliability": order["supplier"]["reliability"],
            "region": order["supplier"]["region"],
            "distance_miles": order["distance_miles"],
        }
        supplier_prediction = self.supplier_model.predict(supplier_features)

        # Inventory optimization
        inventory_features = {
            "product_name": order["product"]["name"],
            "current_stock": order["quantity"],
            "daily_demand": order["quantity"] / order["delivery_days"],
            "lead_time_days": order["delivery_days"],
            "perishable": order["product"]["perishable"],
            "shelf_life_days": order["product"]["shelf_life_days"],
        }
        inventory_prediction = self.inventory_model.predict(inventory_features)

        # Update tenant stats
        order_value = order["quantity"] * order["unit_price"]
        self.tenant_stats[tenant_id]["processed"] += 1
        self.tenant_stats[tenant_id]["revenue"] += order_value
        EVENTS_BY_TENANT.labels(tenant_id=tenant_id).inc()

        prediction = {
            "order_id": order["order_id"],
            "timestamp": datetime.now().isoformat(),
            "tenant_id": tenant_id,
            "predictions": {
                "order_risk": risk_prediction,
                "supplier_reliability": supplier_prediction,
                "inventory_optimization": inventory_prediction,
            },
            "metadata": {
                "product": order["product"]["name"],
                "tenant_name": self.get_tenant_config(tenant_id)["name"],
                "tier": self.get_tenant_config(tenant_id)["tier"],
            },
        }

        return prediction

    def should_alert(self, prediction: Dict[str, Any]) -> bool:
        """Tenant-aware alerting."""
        risk = prediction["predictions"]["order_risk"]
        supplier = prediction["predictions"]["supplier_reliability"]
        inventory = prediction["predictions"]["inventory_optimization"]

        return (
            risk["risk_level"] == "high"
            or supplier["category"] == "poor"
            or inventory["stockout_risk"] == "high"
        )

    def create_alert(
        self, order: Dict[str, Any], prediction: Dict[str, Any]
    ) -> Dict[str, Any]:
        """Create tenant-specific alert."""
        tenant_id = order["tenant_id"]
        tenant_config = self.get_tenant_config(tenant_id)

        risk = prediction["predictions"]["order_risk"]

        alert = {
            "alert_id": f"ALERT-{order['order_id']}",
            "timestamp": datetime.now().isoformat(),
            "order_id": order["order_id"],
            "tenant_id": tenant_id,
            "tenant_name": tenant_config["name"],
            "tier": tenant_config["tier"],
            "severity": "high",
            "message": f"High risk order for {tenant_config['name']}",
            "details": {"risk_score": risk["risk_score"]},
        }

        self.tenant_stats[tenant_id]["alerts"] += 1
        ALERTS_BY_TENANT.labels(tenant_id=tenant_id).inc()

        return alert

    def print_tenant_dashboard(self):
        """Print multi-tenant dashboard."""
        print("\n" + "=" * 80)
        print("üè¢ MULTI-TENANT DASHBOARD")
        print("=" * 80)
        print(f"Active Tenants: {len(self.active_tenants)}")
        print()

        for tenant_id, stats in sorted(self.tenant_stats.items()):
            config = self.get_tenant_config(tenant_id)
            print(f"üìä {config['name']} ({config['tier'].upper()})")
            print(f"   Tenant ID: {tenant_id}")
            print(f"   Orders: {stats['processed']}")
            print(f"   Alerts: {stats['alerts']}")
            print(f"   Revenue: ${stats['revenue']:,.2f}")
            if stats["processed"] > 0:
                alert_rate = (stats["alerts"] / stats["processed"]) * 100
                print(f"   Alert Rate: {alert_rate:.1f}%")
            print()

        print("=" * 80 + "\n")

    def run(self):
        """Main loop."""
        self.consumer.subscribe(["supply-chain.orders"])

        print("\nüè¢ Multi-Tenant ML Consumer Started")
        print("üìä Metrics: http://localhost:9091")
        print("=" * 80)

        try:
            message_count = 0
            while True:
                msg = self.consumer.poll(timeout=1.0)

                if msg is None:
                    continue

                if msg.error():
                    if msg.error().code() != KafkaError._PARTITION_EOF:
                        print(f"‚ùå Error: {msg.error()}")
                    continue

                order = json.loads(msg.value().decode("utf-8"))
                prediction = self.process_order(order)

                # Produce prediction
                self.producer.produce(
                    topic="supply-chain.predictions",
                    key=order["order_id"].encode("utf-8"),
                    value=json.dumps(prediction).encode("utf-8"),
                )

                # Check alerts
                if self.should_alert(prediction):
                    alert = self.create_alert(order, prediction)
                    self.producer.produce(
                        topic="supply-chain.alerts",
                        key=alert["alert_id"].encode("utf-8"),
                        value=json.dumps(alert).encode("utf-8"),
                    )

                self.consumer.commit(asynchronous=False)
                message_count += 1

                # Print dashboard every 50 messages
                if message_count % 50 == 0:
                    self.print_tenant_dashboard()

                self.producer.poll(0)

        except KeyboardInterrupt:
            print("\n\n‚èπÔ∏è  Multi-tenant consumer stopped")
            self.print_tenant_dashboard()
        finally:
            self.consumer.close()
            self.producer.flush()


if __name__ == "__main__":
    consumer = MultiTenantConsumer()
    consumer.run()
