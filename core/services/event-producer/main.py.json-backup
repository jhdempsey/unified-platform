"""
Event Producer Service
HTTP API wrapper for the load generator with Avro serialization support
"""
import os
import json
import threading
from datetime import datetime
from typing import Optional
from fastapi import FastAPI, HTTPException, BackgroundTasks, Query
from fastapi.middleware.cors import CORSMiddleware
import uvicorn

# Import both producers
from producer import OrderEventProducer, OrderEventProducerJSON

# ============================================================================
# FastAPI App
# ============================================================================

app = FastAPI(
    title="Event Producer Service",
    description="Produces test events to Kafka with Avro serialization",
    version="2.0.0"
)

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Global state
_producer_avro: Optional[OrderEventProducer] = None
_producer_json: Optional[OrderEventProducerJSON] = None
_stats = {
    "events_produced_avro": 0,
    "events_produced_json": 0,
    "last_event_time": None,
    "running": False
}

def get_producer_avro() -> OrderEventProducer:
    """Get or create Avro producer instance"""
    global _producer_avro
    if _producer_avro is None:
        _producer_avro = OrderEventProducer()
    return _producer_avro

def get_producer_json() -> OrderEventProducerJSON:
    """Get or create JSON producer instance"""
    global _producer_json
    if _producer_json is None:
        _producer_json = OrderEventProducerJSON()
    return _producer_json

@app.on_event("startup")
async def startup():
    """Initialize producers on startup"""
    global _producer_avro, _producer_json
    print("üöÄ Starting Event Producer Service v2.0...")
    
    # Try to initialize Avro producer (requires Schema Registry)
    try:
        _producer_avro = OrderEventProducer()
        print("‚úÖ Avro producer initialized")
    except Exception as e:
        print(f"‚ö†Ô∏è Avro producer not available: {e}")
        print("   (Schema Registry may not be configured)")
    
    # Always initialize JSON producer as fallback
    try:
        _producer_json = OrderEventProducerJSON()
        print("‚úÖ JSON producer initialized")
    except Exception as e:
        print(f"‚ùå JSON producer failed: {e}")

@app.on_event("shutdown")
async def shutdown():
    """Cleanup on shutdown"""
    global _producer_avro, _producer_json
    if _producer_avro:
        _producer_avro.close()
    if _producer_json:
        _producer_json.close()
    print("üëã Producers closed")

@app.get("/")
async def root():
    """Service info"""
    return {
        "service": "Event Producer",
        "version": "2.0.0",
        "description": "Produces test events to Kafka with Avro or JSON serialization",
        "endpoints": {
            "/health": "Health check",
            "/produce": "Produce a single event (default: Avro)",
            "/produce/{count}": "Produce multiple events",
            "/produce/json": "Produce a single JSON event (legacy)",
            "/produce/json/{count}": "Produce multiple JSON events",
            "/stats": "Production statistics"
        },
        "modes": {
            "avro": _producer_avro is not None,
            "json": _producer_json is not None
        }
    }

@app.get("/health")
async def health():
    """Health check for Cloud Run"""
    avro_available = _producer_avro is not None
    json_available = _producer_json is not None
    
    producer = _producer_avro or _producer_json
    
    return {
        "status": "healthy" if (avro_available or json_available) else "degraded",
        "service": "event-producer",
        "version": "2.0.0",
        "timestamp": datetime.utcnow().isoformat(),
        "kafka_bootstrap": producer.bootstrap_servers if producer else "not connected",
        "modes": {
            "avro": avro_available,
            "json": json_available
        },
        "topics": {
            "avro": "order-event" if avro_available else None,
            "json": "supply-chain.orders" if json_available else None
        }
    }

@app.post("/produce")
async def produce_single(format: str = Query("avro", description="Format: avro or json")):
    """Produce a single event"""
    global _stats
    
    if format == "avro" and _producer_avro:
        producer = _producer_avro
        event = producer.generate_order_event(_stats["events_produced_avro"])
        producer.produce_event(event)
        producer.flush()
        _stats["events_produced_avro"] += 1
    elif _producer_json:
        producer = _producer_json
        event = producer.generate_order_event(_stats["events_produced_json"])
        producer.produce_event(event)
        producer.flush()
        _stats["events_produced_json"] += 1
    else:
        raise HTTPException(status_code=503, detail="No producer available")
    
    _stats["last_event_time"] = datetime.utcnow().isoformat()
    
    return {
        "status": "produced",
        "format": format if format == "avro" and _producer_avro else "json",
        "event": event,
        "topic": producer.topic,
        "total_produced": _stats["events_produced_avro"] + _stats["events_produced_json"]
    }

@app.post("/produce/{count}")
async def produce_multiple(count: int, format: str = Query("avro", description="Format: avro or json")):
    """Produce multiple events"""
    global _stats
    
    if count < 1 or count > 1000:
        raise HTTPException(status_code=400, detail="Count must be between 1 and 1000")
    
    if format == "avro" and _producer_avro:
        producer = _producer_avro
        stats_key = "events_produced_avro"
    elif _producer_json:
        producer = _producer_json
        stats_key = "events_produced_json"
        format = "json"  # Override format
    else:
        raise HTTPException(status_code=503, detail="No producer available")
    
    events_produced = []
    for i in range(count):
        event = producer.generate_order_event(_stats[stats_key] + i)
        producer.produce_event(event)
        events_produced.append(event["order_id"])
    
    producer.flush()
    _stats[stats_key] += count
    _stats["last_event_time"] = datetime.utcnow().isoformat()
    
    return {
        "status": "produced",
        "format": format,
        "count": count,
        "topic": producer.topic,
        "order_ids": events_produced[:10],  # Only return first 10
        "total_produced": _stats["events_produced_avro"] + _stats["events_produced_json"]
    }

@app.post("/produce/json")
async def produce_single_json():
    """Produce a single JSON event (legacy endpoint)"""
    return await produce_single(format="json")

@app.post("/produce/json/{count}")
async def produce_multiple_json(count: int):
    """Produce multiple JSON events (legacy endpoint)"""
    return await produce_multiple(count, format="json")

@app.get("/stats")
async def get_stats():
    """Get production statistics"""
    return {
        "events_produced_avro": _stats["events_produced_avro"],
        "events_produced_json": _stats["events_produced_json"],
        "total_produced": _stats["events_produced_avro"] + _stats["events_produced_json"],
        "last_event_time": _stats["last_event_time"],
        "modes": {
            "avro_available": _producer_avro is not None,
            "json_available": _producer_json is not None
        }
    }

if __name__ == "__main__":
    port = int(os.getenv("PORT", "8080"))
    uvicorn.run(app, host="0.0.0.0", port=port)
