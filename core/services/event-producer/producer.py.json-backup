"""Order Event Producer - Generates supply chain order events with Avro serialization."""

import json
import os
import random
import uuid
import time
from datetime import datetime, timedelta
from typing import Any, Dict

from confluent_kafka import Producer
from confluent_kafka.schema_registry import SchemaRegistryClient
from confluent_kafka.schema_registry.avro import AvroSerializer
from confluent_kafka.serialization import SerializationContext, MessageField


class OrderEventProducer:
    """Produces order events to Kafka with Avro serialization and Schema Registry."""

    # Avro schema matching order-event.avsc
    ORDER_EVENT_SCHEMA = """
    {
      "type": "record",
      "name": "OrderEvent",
      "namespace": "com.platform.events",
      "fields": [
        {"name": "event_id", "type": "string"},
        {"name": "event_type", "type": {"type": "enum", "name": "OrderEventType", "symbols": ["PLACED", "CONFIRMED", "SHIPPED", "DELIVERED", "CANCELLED"]}},
        {"name": "order_id", "type": "string"},
        {"name": "supplier_id", "type": "string"},
        {"name": "customer_id", "type": "string"},
        {"name": "order_total", "type": "double"},
        {"name": "currency", "type": "string", "default": "USD"},
        {"name": "items", "type": {"type": "array", "items": {"type": "record", "name": "OrderItem", "fields": [{"name": "product_id", "type": "string"}, {"name": "quantity", "type": "int"}, {"name": "unit_price", "type": "double"}]}}},
        {"name": "shipping_address", "type": {"type": "record", "name": "Address", "fields": [{"name": "street", "type": "string"}, {"name": "city", "type": "string"}, {"name": "state", "type": ["null", "string"], "default": null}, {"name": "postal_code", "type": "string"}, {"name": "country", "type": "string"}]}},
        {"name": "timestamp", "type": "long", "logicalType": "timestamp-millis"},
        {"name": "metadata", "type": {"type": "map", "values": "string"}, "default": {}}
      ]
    }
    """

    def __init__(self, bootstrap_servers: str = None):
        # Read from environment variable or use default
        if bootstrap_servers is None:
            bootstrap_servers = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092")

        # Get SASL credentials from environment (for Confluent Cloud)
        security_protocol = os.getenv("KAFKA_SECURITY_PROTOCOL", "PLAINTEXT")
        sasl_mechanism = os.getenv("KAFKA_SASL_MECHANISM", "")
        sasl_username = os.getenv("KAFKA_SASL_USERNAME", "")
        sasl_password = os.getenv("KAFKA_SASL_PASSWORD", "")

        # Schema Registry config
        sr_url = os.getenv("SCHEMA_REGISTRY_URL", "http://localhost:8081")
        sr_api_key = os.getenv("SCHEMA_REGISTRY_API_KEY", "")
        sr_api_secret = os.getenv("SCHEMA_REGISTRY_API_SECRET", "")

        # Base Kafka config
        self.config = {
            "bootstrap.servers": bootstrap_servers,
            "client.id": "order-producer-avro",
            "acks": "all",
            "enable.idempotence": True,
        }

        # Add SASL config if using SASL_SSL (Confluent Cloud)
        if security_protocol == "SASL_SSL":
            self.config.update({
                'security.protocol': security_protocol,
                'sasl.mechanism': sasl_mechanism,
                'sasl.username': sasl_username,
                'sasl.password': sasl_password,
            })
            print(f"ðŸ” Using SASL_SSL authentication to {bootstrap_servers}")
        else:
            print(f"ðŸ”“ Using PLAINTEXT connection to {bootstrap_servers}")

        # Initialize Schema Registry client
        sr_config = {"url": sr_url}
        if sr_api_key and sr_api_secret:
            sr_config["basic.auth.user.info"] = f"{sr_api_key}:{sr_api_secret}"
            print(f"ðŸ” Schema Registry: {sr_url} (authenticated)")
        else:
            print(f"ðŸ”“ Schema Registry: {sr_url} (no auth)")

        self.schema_registry_client = SchemaRegistryClient(sr_config)
        
        # Initialize Avro serializer
        self.avro_serializer = AvroSerializer(
            self.schema_registry_client,
            self.ORDER_EVENT_SCHEMA,
            self._order_to_dict
        )

        self.producer = Producer(self.config)
        self.topic = "order-event"  # Topic name matches schema subject
        self.bootstrap_servers = bootstrap_servers

        print(f"ðŸ”— Connected to Kafka: {bootstrap_servers}")
        print(f"ðŸ“‹ Using Avro serialization with Schema Registry")

    def _order_to_dict(self, order: Dict[str, Any], ctx) -> Dict[str, Any]:
        """Convert order object to dict for Avro serialization."""
        return order

    def delivery_report(self, err, msg):
        """Callback for message delivery reports."""
        if err is not None:
            print(f"âŒ Message delivery failed: {err}")
        else:
            topic = msg.topic()
            partition = msg.partition()
            offset = msg.offset()
            print(f"âœ… Message delivered to {topic} [{partition}] @ offset {offset}")

    def generate_order_event(self, order_id: int) -> Dict[str, Any]:
        """Generate a realistic supply chain order event matching Avro schema."""

        products = [
            {"id": "PROD-001", "name": "Organic Tomatoes", "category": "Produce", "price": 4.99},
            {"id": "PROD-002", "name": "Steel Bolts M8", "category": "Hardware", "price": 12.50},
            {"id": "PROD-003", "name": "Fresh Salmon Fillet", "category": "Seafood", "price": 24.99},
            {"id": "PROD-004", "name": "Industrial Lubricant", "category": "Chemicals", "price": 89.99},
            {"id": "PROD-005", "name": "Organic Milk", "category": "Dairy", "price": 5.99},
        ]

        suppliers = [
            {"id": "SUP-001", "name": "Fresh Farms Co", "region": "West"},
            {"id": "SUP-002", "name": "Steel Masters", "region": "Midwest"},
            {"id": "SUP-003", "name": "Ocean Fresh", "region": "East"},
            {"id": "SUP-004", "name": "ChemCorp", "region": "South"},
            {"id": "SUP-005", "name": "Dairy Direct", "region": "North"},
        ]

        customers = [
            {"id": "CUST-001", "city": "Seattle", "state": "WA"},
            {"id": "CUST-002", "city": "Chicago", "state": "IL"},
            {"id": "CUST-003", "city": "New York", "state": "NY"},
            {"id": "CUST-004", "city": "Houston", "state": "TX"},
            {"id": "CUST-005", "city": "Denver", "state": "CO"},
        ]

        cities = [
            {"street": "123 Main St", "city": "Seattle", "state": "WA", "postal_code": "98101", "country": "USA"},
            {"street": "456 Oak Ave", "city": "Chicago", "state": "IL", "postal_code": "60601", "country": "USA"},
            {"street": "789 Broadway", "city": "New York", "state": "NY", "postal_code": "10001", "country": "USA"},
            {"street": "321 Texas Blvd", "city": "Houston", "state": "TX", "postal_code": "77001", "country": "USA"},
            {"street": "654 Mountain Rd", "city": "Denver", "state": "CO", "postal_code": "80201", "country": "USA"},
        ]

        event_types = ["PLACED", "CONFIRMED", "SHIPPED", "DELIVERED", "CANCELLED"]

        # Generate random items
        num_items = random.randint(1, 5)
        items = []
        total = 0.0
        for _ in range(num_items):
            product = random.choice(products)
            quantity = random.randint(1, 20)
            unit_price = product["price"]
            items.append({
                "product_id": product["id"],
                "quantity": quantity,
                "unit_price": unit_price
            })
            total += quantity * unit_price

        supplier = random.choice(suppliers)
        customer = random.choice(customers)
        address = random.choice(cities)

        order_event = {
            "event_id": str(uuid.uuid4()),
            "event_type": random.choice(event_types),
            "order_id": f"ORD-{order_id:06d}",
            "supplier_id": supplier["id"],
            "customer_id": customer["id"],
            "order_total": round(total, 2),
            "currency": "USD",
            "items": items,
            "shipping_address": address,
            "timestamp": int(datetime.utcnow().timestamp() * 1000),
            "metadata": {
                "source": "event-producer",
                "region": supplier["region"]
            }
        }

        return order_event

    def produce_event(self, event: Dict[str, Any]):
        """Produce an Avro-serialized event to Kafka."""
        try:
            # Serialize with Avro
            serialized_value = self.avro_serializer(
                event,
                SerializationContext(self.topic, MessageField.VALUE)
            )
            
            self.producer.produce(
                topic=self.topic,
                key=event["order_id"].encode("utf-8"),
                value=serialized_value,
                callback=self.delivery_report,
            )
            self.producer.poll(0)
        except Exception as e:
            print(f"âŒ Error producing event: {e}")
            raise

    def flush(self):
        """Flush all pending messages."""
        self.producer.flush()

    def close(self):
        """Close the producer."""
        self.flush()
        print("ðŸ‘‹ Producer closed")


# Keep the JSON producer for backward compatibility
class OrderEventProducerJSON:
    """Produces order events to Kafka as JSON (backward compatible)."""

    def __init__(self, bootstrap_servers: str = None):
        if bootstrap_servers is None:
            bootstrap_servers = os.getenv("KAFKA_BOOTSTRAP_SERVERS", "localhost:9092")

        security_protocol = os.getenv("KAFKA_SECURITY_PROTOCOL", "PLAINTEXT")
        sasl_mechanism = os.getenv("KAFKA_SASL_MECHANISM", "")
        sasl_username = os.getenv("KAFKA_SASL_USERNAME", "")
        sasl_password = os.getenv("KAFKA_SASL_PASSWORD", "")

        self.config = {
            "bootstrap.servers": bootstrap_servers,
            "client.id": "order-producer-json",
            "acks": "all",
            "enable.idempotence": True,
        }

        if security_protocol == "SASL_SSL":
            self.config.update({
                'security.protocol': security_protocol,
                'sasl.mechanism': sasl_mechanism,
                'sasl.username': sasl_username,
                'sasl.password': sasl_password,
            })

        self.producer = Producer(self.config)
        self.topic = "supply-chain.orders"
        self.bootstrap_servers = bootstrap_servers

    def delivery_report(self, err, msg):
        if err is not None:
            print(f"âŒ Message delivery failed: {err}")
        else:
            print(f"âœ… Message delivered to {msg.topic()} [{msg.partition()}] @ {msg.offset()}")

    def generate_order_event(self, order_id: int) -> Dict[str, Any]:
        products = [
            {"name": "Organic Tomatoes", "category": "Produce", "perishable": True, "shelf_life_days": 7},
            {"name": "Steel Bolts M8", "category": "Hardware", "perishable": False, "shelf_life_days": 3650},
            {"name": "Fresh Salmon Fillet", "category": "Seafood", "perishable": True, "shelf_life_days": 3},
            {"name": "Industrial Lubricant", "category": "Chemicals", "perishable": False, "shelf_life_days": 365},
            {"name": "Organic Milk", "category": "Dairy", "perishable": True, "shelf_life_days": 14},
        ]

        suppliers = [
            {"id": "SUP-001", "name": "Fresh Farms Co", "region": "West", "reliability": 0.95},
            {"id": "SUP-002", "name": "Steel Masters", "region": "Midwest", "reliability": 0.88},
            {"id": "SUP-003", "name": "Ocean Fresh", "region": "East", "reliability": 0.92},
            {"id": "SUP-004", "name": "ChemCorp", "region": "South", "reliability": 0.85},
            {"id": "SUP-005", "name": "Dairy Direct", "region": "North", "reliability": 0.91},
        ]

        tenants = ["tenant-retail-001", "tenant-mfg-002", "tenant-food-003"]

        return {
            "order_id": f"ORD-{order_id:06d}",
            "tenant_id": random.choice(tenants),
            "timestamp": datetime.utcnow().isoformat(),
            "product": random.choice(products),
            "supplier": random.choice(suppliers),
            "quantity": random.randint(10, 1000),
            "unit_price": round(random.uniform(1.0, 100.0), 2),
            "delivery_days": random.randint(1, 14),
            "distance_miles": random.randint(50, 3000),
            "weather_risk": random.choice(["low", "medium", "high"]),
            "priority": random.choice(["standard", "express", "critical"]),
        }

    def produce_event(self, event: Dict[str, Any]):
        self.producer.produce(
            topic=self.topic,
            key=event["order_id"].encode("utf-8"),
            value=json.dumps(event).encode("utf-8"),
            callback=self.delivery_report,
        )
        self.producer.poll(0)

    def flush(self):
        self.producer.flush()

    def close(self):
        self.flush()
